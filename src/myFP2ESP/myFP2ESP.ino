// ======================================================================
// myFP2ESP myp2esp.ino FIRMWARE OFFICIAL RELEASE 230 [18-July-2021]
// (c) Copyright Robert Brown 2014-2021. All Rights Reserved.
// (c) Copyright Holger M, 2019-2021. All Rights Reserved.
// (c) Copyright Pieter P - OTA code and SPIFFs file handling/upload based on examples
// (c) Copyright Paul P, 2021. All Rights Reserved. TMC22xx code
// ======================================================================
//
// myFP2ESP Firmware for ESP8266 and ESP32 myFocuserPro2 WiFi Controllers
// Supports Driver boards DRV8825, ULN2003, L298N, L9110S, L293DMINI, L293D, TMC2209, TMC2225
// ESP8266  OLED display, Temperature Probe
// ESP32    OLED display, Temperature Probe, Push Buttons, In/Out LED's,
//          Infrared Remote, Bluetooth
// Supports modes, ACCESSPOINT, STATIONMODE, BLUETOOTH, LOCALSERIAL, WEBSERVER,
//          ASCOMREMOTE
// Remember to change your target CPU depending on board selection
//
// ======================================================================
// SPECIAL LICENSE
// ======================================================================
// This code is released under license. If you copy or write new code based
// on the code in these files, you MUST include a link to these files AND
// you MUST include references to the authors of this code.

// ======================================================================
// CONTRIBUTIONS
// ======================================================================
// It is costly to continue development and purchase boards and components.
// Your support is needed to continue development of this project. Please
// contribute to this project, and use PayPal to send your donation to user
// rbb1brown@gmail.com (Robert Brown). All contributions are gratefully accepted.

#include "boarddefs.h"                      // include driver board and motor high level definitions
#include "generalDefinitions.h"             // include global definitions
#include "myBoards.h"                       // include driverboard class definitions
#include "focuserconfig.h"

// ======================================================================
// INCLUDES
// ======================================================================

#undef DEBUG_ESP_HTTP_SERVER                // needed sometimes to prevent serial output from WiFiServerlibrary

#include <WiFiServer.h>
#include <WiFiClient.h>
#include <ArduinoJson.h>

#if defined(ESP8266)                        // generated by Arduino IDE
#undef DEBUG_ESP_HTTP_SERVER                // prevent messages from WiFiServer 
#include <ESP8266WiFi.h>
#include <FS.h>                             // include the SPIFFS library  
#else                                       // otherwise assume ESP32
#include <WiFi.h>
#include "SPIFFS.h"
#endif
#include <SPI.h>
#include "FocuserSetupData.h"

// ======================================================================
// OVERVIEW: TO PROGRAM THE FIRMWARE
// ======================================================================
// 1. Set your DRVBRD in focuserconfig.h so the correct driver board is used
// 2. For specific boards set the FIXEDSTEPMODE in focuserconfig.h
// 3. For specific boards set the STEPSPERREVOLUTION in focuserconfig.h
// 4. Enable Display type [if fitted[ in focuserconfig.h
// 5. Set hardware options for JoyStick/IRRemote [esp32 only] in focuserconfig.h
// 6. Set the controller mode in focuserconfig.h
// 7. Set the controller protocol in focuserconfig.h
// 8. Set your target CPU to match the correct CPU for your board
// 9. Compile and upload to your controller
// 10. Upload the sketch data files

// ======================================================================
// 1: SPECIFY DRIVER BOARD in 1: focuserconfig.h
// ======================================================================
// Please specify your driver board [DRVBRD] in focuserconfig.h

// ======================================================================
// 2: SPECIFY FIXEDSTEPMODE in 2: focuserconfig.h
// ======================================================================
// For specific boards, specify the correct FIXEDSTEPMODE focuserconfig.h

// ======================================================================
// 3: SPECIFY STEPSPERREVOLUTION in 3: focuserconfig.h
// ======================================================================
// For specific boards, specify the correct STEPSPERREVOLUTION focuserconfig.h

// ======================================================================
// 4: SPECIFY DISPLAY OPTIONS IN 4: focuserconfig.h
// ======================================================================
// Specify your display options in focuserconfig.h, such as OLEDTEXT

// ======================================================================
// 5: SPECIFY HARDWARE OPTIONS IN 5: focuserconfig.h
// ======================================================================
// Specify your controller options in focuserconfig.h, such as INFRAREDREMOTE

// ======================================================================
// 6: SPECIFY THE CONTROLLER MODE IN 6: focuserconfig.h
// ======================================================================
// Please specify your controller mode in focuserconfig.h, such as
// ACCESSPOINT, STATIONMODE, LOCALSERIAL or BLUETOOTHMODE

// ======================================================================
// 7: SPECIFY CONTROLLER OPTIONS in 7: focuserconfig.h
// ======================================================================
// Please specify your controller options in focuserconfig.h, such as
// OTAUPDATES, MDNSSERVER, MANAGEMENT, USEDUCKDNS and READWIFICONFIG

// ======================================================================
// 8: SPECIFY CONTROLLER PROTOCOL in 8: focuserconfig.h
// ======================================================================
// Please specify the controller protocol in focuserconfig.h, such as
// MYFP2ESP_PROTOCOL or MOONLITE_PROTOCOL

// ======================================================================
// WIFI NETWORK CREDENTIALS: SSID AND PASSWORD
// ======================================================================
// 1. For access point mode this is the network you connect to
// 2. For station mode, change mySSID and myPASSWORD to match your network details

char mySSID[64]     = "myfp2eap";
char myPASSWORD[64] = "myfp2eap";

// Alternative network credentials if initial details above did not work
char mySSID_1[64]     = "FireFox";            // alternate network id
char myPASSWORD_1[64] = "AllYeWhoEnter";      // alternate network id


// ======================================================================
// STATIC IP ADDRESS CONFIGURATION
// ======================================================================
// must use static IP if using duckdns or as an Access Point
#ifndef STATICIPON
#define STATICIPON    1
#endif
#ifndef STATICIPOFF
#define STATICIPOFF   0
#endif
//int staticip = STATICIPON;                  // IP address specified by controller - must be defined correctly
int staticip = STATICIPOFF;                   // IP address is generated by network device and is dynamic and can change

#if (CONTROLLERMODE == ACCESSPOINT)
// By default the Access point should be 192.168.4.1 - DO NOT CHANGE
IPAddress ip(192, 168, 4, 1);                 // AP static IP - you can change these values to change the IP
IPAddress dns(192, 168, 4, 1);                // just set it to the same IP as the gateway
IPAddress gateway(192, 168, 4, 1);
IPAddress subnet(255, 255, 255, 0);
#endif // #if (CONTROLLERMODE == ACCESSPOINT)

#if (CONTROLLERMODE == STATIONMODE)
// These need to reflect your current network settings - 192.168.x.21 - change x
// This has to be within the range for dynamic ip allocation in the router
// No effect if staticip = STATICIPOFF
IPAddress ip(192, 168, 2, 21);                // station static IP - you can change these values to change the IP
IPAddress dns(192, 168, 2, 1);                // just set it to the same IP as the gateway
IPAddress gateway(192, 168, 2, 1);
IPAddress subnet(255, 255, 255, 0);
#endif // #if (CONTROLLERMODE == STATIONMODE)


// ======================================================================
// BLUETOOTH MODE NAME
// ======================================================================
#if (CONTROLLERMODE == BLUETOOTHMODE)
String BLUETOOTHNAME = "MYFP3ESP32BT";      // default name for Bluetooth controller
#endif // #ifdef BLUETOOTHMODE


// ======================================================================
// mDNS NAME: Name must be alphabetic chars only, lowercase
// ======================================================================
#ifdef MDNSSERVER
char mDNSNAME[] = "myfp2eap";               // mDNS name will be myfp2eap.local
#endif // #ifdef MDNSSERVER


// ======================================================================
// OTAUPDATES (OVER THE AIR UPDATE) SSID AND PASSWORD CONFIGURATION
// ======================================================================
// You can change the values for OTANAME and OTAPassword if required
#ifdef OTAUPDATES
#include <ArduinoOTA.h>
const char *OTAName = "ESP8266";            // the username and password for the OTA service
const char *OTAPassword = "esp8266";
#endif // #ifdef OTAUPDATES


// ======================================================================
// DUCKDNS DOMAIN AND TOKEN CONFIGURATION
// ======================================================================
// if using DuckDNS you need to set these next two parameters, duckdnsdomain
// and duckdnstoken, BUT you cannot use DuckDNS with ACCESSPOINT, BLUETOOTHMODE
// or LOCALSERIAL mode
#ifdef USEDUCKDNS
const char* duckdnsdomain = "myfp2erobert.duckdns.org";
const char* duckdnstoken = "0a0379d5-3979-44ae-b1e2-6c371a4fe9bf";
#endif // #ifdef USEDUCKDNS


// ======================================================================
// FIRMWARE CODE START - INCLUDES AND LIBRARIES
// ======================================================================

// BLUETOOTH SETTINGS - Do not change
#if (CONTROLLERMODE == BLUETOOTHMODE)
#include "BluetoothSerial.h"                  // needed for Bluetooth comms
#if !defined(CONFIG_BT_ENABLED) || !defined(CONFIG_BLUEDROID_ENABLED)
#error "Bluetooth Not enabled"
#endif
BluetoothSerial SerialBT;                     // define BT adapter to use
String btline;                                // buffer for serial data
#endif // BLUETOOTHMODE

// Project specific includes - DO NOT CHANGE
#if (CONTROLLERMODE == LOCALSERIAL || PROTOCOL == MOONLITE_PROTOCOL)
#include "ESPQueue.h"                         // by Steven de Salas
Queue queue(QUEUELENGTH);                     // receive serial queue of commands
String serialline;                            // buffer for serial data
#endif // #if defined(LOCALSERIAL)

#if ((CONTROLLERMODE == ACCESSPOINT) || (CONTROLLERMODE == STATIONMODE))
IPAddress  ESP32IPAddress;
//String     ServerLocalIP;
WiFiServer myserver(SERVERPORT);
WiFiClient myclient;                          // only one client supported, multiple connections denied
IPAddress  myIP;
#endif // #if ((CONTROLLERMODE == ACCESSPOINT) || (CONTROLLERMODE == STATIONMODE))

#include "temp.h"
TempProbe *myTempProbe;

#include "displays.h"
OLED_NON *myoled;


// ======================================================================
// GLOBAL DATA -- DO NOT CHANGE
// ======================================================================

//           reversedirection
//__________________________________
//               0   |   1
//__________________________________
//moving_out  1||  1   |   0
//moving_in   0||  0   |   1

volatile bool timerSemaphore = false;       // move completed=true, still moving or not moving = false;
volatile uint32_t stepcount;                // number of steps to go in timer interrupt service routine
volatile bool halt_alert;
#if defined(ESP8266)
// in esp8266, volatile data_type varname is all that is needed
#else
// in esp32, we should use a Mutex for access
portMUX_TYPE  timerSemaphoreMux = portMUX_INITIALIZER_UNLOCKED; // shared vars in interrupt routines must control access via mutex
portMUX_TYPE  stepcountMux = portMUX_INITIALIZER_UNLOCKED;
portMUX_TYPE  halt_alertMux = portMUX_INITIALIZER_UNLOCKED;
#endif

DriverBoard   *driverboard;
SetupData     *mySetupData;                 // focuser data

unsigned long ftargetPosition;              // target position
bool    displayfound;
byte    isMoving;                           // is the motor currently moving
char    ipStr[16] = "000.000.000.000";      // shared between BT mode and other modes

long    rssi;                               // network signal strength
int     packetsreceived;
int     packetssent;
bool    mdnsserverstate;                    // states for services, RUNNING | STOPPED
bool    webserverstate;
bool    ascomserverstate;
bool    ascomdiscoverystate;
bool    managementserverstate;
bool    tcpipserverstate;
bool    otaupdatestate;
bool    duckdnsstate;
bool    displaystate;                       // true if a display was found
bool    irremotestate;
bool    reboot;                             // flag used to indicate a reboot has occurred
int     tprobe1;                            // true if a temperature probe was detected
float   lasttemp;                           // last valid temp reading

#if defined(ESP8266)
#undef DEBUG_ESP_HTTP_SERVER
#include <ESP8266WebServer.h>
extern ESP8266WebServer mserver;
extern ESP8266WebServer *ascomserver;
#else
#include <WebServer.h>
extern WebServer mserver;
extern WebServer *ascomserver;
#endif // if defined(esp8266)

extern void start_management(void);
extern void start_ascomremoteserver(void);
extern void checkASCOMALPACADiscovery(void);
extern void start_webserver(void);

extern void cachepresets(void);

// ======================================================================
// FIRMWARE CODE START - CHANGE AT YOUR OWN PERIL
// ======================================================================
#if (PROTOCOL == MYFP2ESP_PROTOCOL)
#include "comms.h"                                // do not change or move
#else
#include "moonlitecomms.h"
#endif

// ======================================================================
// INFRARED REMOTE CONTROLLER - CHANGE AT YOUR OWN PERIL
// ======================================================================
#ifdef INFRAREDREMOTE
#include <myfp2eIRremoteESP8266.h>                    // use cut down version to save spave
#include <myfp2eIRrecv.h>                             // unable to turn off all options by using a define
#include <myfp2eIRutils.h>
#include "irremotemappings.h"
const uint16_t RECV_PIN = 15;
IRrecv *irrecv;
decode_results results;

void update_irremote()
{
  if ( irremotestate == true )
  {
    // check IR
    if (irrecv->decode(&results))
    {
      int adjpos = 0;
      static long lastcode;
      if ( results.value == KEY_REPEAT )
      {
        results.value = lastcode;                   // repeat last code
      }
      else
      {
        lastcode = results.value;
      }
      if ( (isMoving == 1) && (lastcode == IR_HALT))
      {
        varENTER_CRITICAL(&halt_alertMux);
        halt_alert = true;
        varEXIT_CRITICAL(&halt_alertMux);
      }
      else
      {
        switch ( lastcode )
        {
          case IR_SLOW:
            mySetupData->set_motorspeed(SLOW);
            break;
          case IR_MEDIUM:
            mySetupData->set_motorspeed(MED);
            break;
          case IR_FAST:
            mySetupData->set_motorspeed(FAST);
            break;
          case IR_IN1:
            adjpos = -1;
            break;
          case IR_OUT1:
            adjpos = 1;
            break;
          case IR_IN10:
            adjpos = -10;
            break;
          case IR_OUT10:
            adjpos = 10;
            break;
          case IR_IN50:
            adjpos = -50;
            break;
          case IR_OUT50:
            adjpos = 50;
            break;
          case IR_IN100:
            adjpos = -100;
            break;
          case IR_OUT100:
            adjpos = 100;
            break;
          case IR_SETPOSZERO:                         // 0 RESET POSITION TO 0
            adjpos = 0;
            ftargetPosition = 0;
            driverboard->setposition(0);
            mySetupData->set_fposition(0);
            break;
          case IR_PRESET0:
            ftargetPosition = mySetupData->get_focuserpreset(0);
            break;
          case IR_PRESET1:
            ftargetPosition = mySetupData->get_focuserpreset(1);
            break;
          case IR_PRESET2:
            ftargetPosition = mySetupData->get_focuserpreset(2);
            break;
          case IR_PRESET3:
            ftargetPosition = mySetupData->get_focuserpreset(3);
            break;
          case IR_PRESET4:
            ftargetPosition = mySetupData->get_focuserpreset(4);
            break;
        } // switch(lastcode)
      } // if ( (isMoving == 1) && (lastcode == IR_HALT))
      irrecv->resume();                              // Receive the next value
      long newpos;
      if ( adjpos < 0 )
      {
        newpos = mySetupData->get_fposition() + adjpos;
        newpos = (newpos < 0 ) ? 0 : newpos;
        ftargetPosition = newpos;
      }
      else if ( adjpos > 0)
      {
        newpos = mySetupData->get_fposition() + adjpos;
        newpos = (newpos > mySetupData->get_maxstep()) ? mySetupData->get_maxstep() : newpos;
        ftargetPosition = newpos;
      }
    }
  }
  else
  {
    Setup_DebugPrintln("Cannot start irremote: board pin is -1");
  }
}

void init_irremote(void)
{
  Setup_DebugPrintln("init_irremote");
  irremotestate = false;
  if ( mySetupData->get_brdirpin() != -1 )
  {
    irrecv = new IRrecv(mySetupData->get_brdirpin());
    irrecv->enableIRIn();                            // Start the IR
    irremotestate = true;
  }
  else
  {
    Setup_DebugPrintln("Cannot start irremote: board pin is -1");
    irremotestate = false;
  }
}
#endif // #ifdef INFRAREDREMOTE

// ======================================================================
// JOYSTICK - CHANGE AT YOUR OWN PERIL
// ======================================================================
#if defined(JOYSTICK1) || defined(JOYSTICK2)
#include "joystick.h"

#ifdef JOYSTICK2
volatile bool joy2swstate = false;
#endif

// 2-AXIS Analog Thumb Joystick for Arduino
#ifdef JOYSTICK1
void update_joystick1(void)
{
  static int joyval;
  static long newpos;
  DebugPrintln("update joystick");
  joyval = analogRead(JOYINOUTPIN);
  DebugPrint("Raw joyval:");
  DebugPrintln(joyval);
  if ( joyval < (JZEROPOINT - JTHRESHOLD) )
  {
    newpos = ftargetPosition - 1;
    newpos = (newpos < 0 ) ? 0 : newpos;
    ftargetPosition = newpos;
    DebugPrint("X IN joyval:");
    DebugPrint(joyval);
  }
  else if ( joyval > (JZEROPOINT + JTHRESHOLD) )
  {
    newpos = ftargetPosition + 1;
    // an unsigned long range is 0 to 4,294,967,295
    // when an unsigned long decrements from 0-1 it goes to largest +ve value, ie 4,294,967,295
    // which would in likely be much much greater than maxstep
    newpos = (newpos > (long) mySetupData->get_maxstep()) ? (long) mySetupData->get_maxstep() : newpos;
    ftargetPosition = newpos;
    DebugPrint("X OUT joyval:");
    DebugPrint(joyval);
  }
}

void init_joystick1(void)
{
  // perform any inititalisations necessary
  pinMode(JOYINOUTPIN, INPUT);
  //pinMode(JOYOTHERPIN, INPUT);      // otherpin is not used in Joystick1
}
#endif // #ifdef JOYSTICK1

// Keyes KY-023 PS2 style 2-Axis Joystick
#ifdef JOYSTICK2
void IRAM_ATTR joystick2sw_isr()
{ // an interrupt means switch has been pressed
  joy2swstate = true;                             // flag joy2swstate set to 1 indicates switch is pressed
}

void update_joystick2(void)
{
  static int joyval;
  static long newpos;
  joyval = analogRead(JOYINOUTPIN);               // range is 0 - 4095, midpoint is 2047
  DebugPrint("Raw joyval:");
  DebugPrintln(joyval);
  if ( joyval < (JZEROPOINT - JTHRESHOLD) )
  {
    newpos = ftargetPosition - 1;
    newpos = (newpos < 0 ) ? 0 : newpos;
    ftargetPosition = newpos;
    DebugPrint("X IN joyval:");
    DebugPrint(joyval);
  }
  else if ( joyval > (JZEROPOINT + JTHRESHOLD) )
  {
    newpos = ftargetPosition + 1;
    // an unsigned long range is 0 to 4,294,967,295
    // when an unsigned long decrements from 0-1 it goes to largest +ve value, ie 4,294,967,295
    // which would in likely be much much greater than maxstep
    newpos = (newpos > (long) mySetupData->get_maxstep()) ? (long) mySetupData->get_maxstep() : newpos;
    ftargetPosition = newpos;
    DebugPrint("X OUT joyval:");
    DebugPrintln(joyval);
  }

  if ( joy2swstate == true)                         // switch is pressed
  {
    // user defined code here
    // could be a halt
    // could be a home
    // could be a preset
    // insert code here

    joy2swstate = false;                        // finally reset joystick switch state in update_joystick2()
  }
}

void init_joystick2(void)
{
  pinMode(JOYINOUTPIN, INPUT);
  pinMode(JOYOTHERPIN, INPUT);                  // otherpin is the switch botton on Joystick2
  // setup interrupt, falling edge, pin state = HIGH and falls to GND (0) when pressed
  attachInterrupt(JOYOTHERPIN, joystick2sw_isr, FALLING);
  joy2swstate = false;                          // after interrupt is processed, the joy2swtate is reset to 0
}
#endif // #ifdef JOYSTICK2

#endif // #if defined(JOYSTICK1) || defined(JOYSTICK2)

// ======================================================================
// PUSHBUTTONS - CHANGE AT YOUR OWN PERIL
// ======================================================================
bool init_pushbuttons(void)
{
  Setup_DebugPrintln("initPB: ");
  if ( (mySetupData->get_brdpb1pin() != -1) && (mySetupData->get_brdpb2pin() != -1) )
  {
    // Basic assumption rule: If associated pin is -1 then cannot set enable
    if ( mySetupData->get_pbenable() == 1)
    {
      pinMode(mySetupData->get_brdpb1pin(), INPUT);
      pinMode(mySetupData->get_brdpb2pin(), INPUT);
      Setup_DebugPrintln("enabled");
      return true;
    }
    else
    {
      Setup_DebugPrintln("disabled");
    }
  }
  else
  {
    Setup_DebugPrintln("not permitted");
  }
  return false;
}

void update_pushbuttons(void)
{
  static long newpos;
  //DebugPrint("updatePB: ");
  // check to see if the pins for pb-in and pb-out are defined in the board configuration file
  // Any pin - if not used in a board configuration, it will be set to -1 in the board configuration file
  // if the pin is defined for this board - then getbrdpin returns board pin number, if not used then getbrdpin returns -1
  if ( (mySetupData->get_brdpb1pin() != -1) && (mySetupData->get_brdpb2pin() != -1) )
  {
    // check to see if push buttons are enabled
    if ( mySetupData->get_pbenable() == 1)
    {
      // PB are active high - pins are low by virtue of pull down resistors through J16 and J17 jumpers
      // read from the board pin number, and compare the return pin value - if 1 then button is pressed
      if ( digitalRead(mySetupData->get_brdpb1pin()) == 1 )
      {
        newpos = ftargetPosition - 1;
        newpos = (newpos < 0 ) ? 0 : newpos;
        ftargetPosition = newpos;
        //DebugPrintln("pb1 updated");
      }
      if ( digitalRead(mySetupData->get_brdpb2pin()) == 1 )
      {
        newpos = ftargetPosition + 1;
        // an unsigned long range is 0 to 4,294,967,295
        // when an unsigned long decrements from 0-1 it goes to largest +ve value, ie 4,294,967,295
        // which would in likely be much much greater than maxstep
        newpos = (newpos > (long) mySetupData->get_maxstep()) ? (long) mySetupData->get_maxstep() : newpos;
        ftargetPosition = newpos;
        //DebugPrintln("pb2 updated");
      }
    }
    else
    {
      //DebugPrintln("disabled");
    }
  }
  else
  {
    //DebugPrintln("not permitted");
  }
}

// ======================================================================
// mDNS SERVER - CHANGE AT YOUR OWN PERIL
// ======================================================================
#ifdef MDNSSERVER
#if defined(ESP8266)
#include <ESP8266mDNS.h>
#else
#include <ESPmDNS.h>
#endif

// MDNS service. find the device using dnsname.local
void start_mdns_service(void)
{
  // Set up mDNS responder: the fully-qualified domain name is "mDNSNAME.local"
  Setup_DebugPrintln("MDNS: ");
#if defined(ESP8266)
  if (!MDNS.begin(mDNSNAME, WiFi.localIP()))      // ESP8266 supports additional parameter for IP
#else
  if (!MDNS.begin(mDNSNAME))                      // ESP32 does not support IPaddress parameter
#endif
  {
    Setup_DebugPrintln("Not started");
    mdnsserverstate = STOPPED;
  }
  else
  {
    Setup_DebugPrintln("Started");
    MDNS.addService("http", "tcp", MDNSSERVERPORT); // Add service to MDNS-SD, MDNS.addService(service, proto, port)
    mdnsserverstate = RUNNING;
  }
  delay(10);                                        // small pause so background tasks can run
}

void stop_mdns_service(void)
{
  Setup_DebugPrint("mdns: ");
  if ( mdnsserverstate == RUNNING )
  {
#if defined(ESP8266)
    // ignore
    // esp8266 library has no end() function to release mdns
#else
    MDNS.end();
#endif
    Setup_DebugPrintln("stopped");
    mdnsserverstate = STOPPED;
  }
  else
  {
    Setup_DebugPrintln("Not running");
  }
  delay(10);                      // small pause so background tasks can run
}
#endif // #ifdef MDNSSERVER

// ======================================================================
// WEBSERVER - CHANGE AT YOUR OWN PERIL
// ======================================================================
#if defined(ESP8266)
#undef DEBUG_ESP_HTTP_SERVER
#include <ESP8266WebServer.h>
#else
#include <WebServer.h>
#endif // if defined(esp8266)

#include "webserver.h"
#if defined(ESP8266)
#undef DEBUG_ESP_HTTP_SERVER
extern ESP8266WebServer *webserver;
#else
extern WebServer *webserver;
#endif // if defined(esp8266)

// ======================================================================
// OTAUPDATES - CHANGE AT YOUR OWN PERIL
// ======================================================================
#if defined(OTAUPDATES)
#include <ArduinoOTA.h>

void start_otaservice()
{
  Setup_DebugPrint("Start OTA:");
  myoled->oledtextmsg("Start OTA", -1, false, true);
  ArduinoOTA.setHostname(OTAName);                      // Start the OTA service
  ArduinoOTA.setPassword(OTAPassword);

  ArduinoOTA.onStart([]()
  {
    Setup_DebugPrintln("Started");
  });
  ArduinoOTA.onEnd([]()
  {
    Setup_DebugPrintln("End");
  });
  ArduinoOTA.onProgress([](unsigned int progress, unsigned int total)
  {
    DebugPrint("Progress:");
    DebugPrintln((progress / (total / 100)));
  });
  ArduinoOTA.onError([](ota_error_t error)
  {
    Setup_DebugPrint("Err:");
    Setup_DebugPrintln(error);
    if (error == OTA_AUTH_ERROR)
    {
      Setup_DebugPrintln("err Auth");
    }
    else if (error == OTA_BEGIN_ERROR)
    {
      Setup_DebugPrintln("err Begin");
    }
    else if (error == OTA_CONNECT_ERROR)
    {
      Setup_DebugPrintln("err Connect");
    }
    else if (error == OTA_RECEIVE_ERROR)
    {
      Setup_DebugPrintln("err Receive");
    }
    else if (error == OTA_END_ERROR)
    {
      Setup_DebugPrintln("err End");
    }
  });
  ArduinoOTA.begin();
  Setup_DebugPrintln("Ready");
  otaupdatestate = RUNNING;
}
#endif // #if defined(OTAUPDATES)

// ======================================================================
// DUCKDNS - CHANGE AT YOUR OWN PERIL
// ======================================================================
#ifdef USEDUCKDNS
#include <EasyDDNS.h>                           // https://github.com/ayushsharma82/EasyDDNS

void init_duckdns(void)
{
  Setup_DebugPrintln("initDuckDNS:");
  myoled->oledtextmsg("Start DuckDNS", -1, false, true);
  EasyDDNS.service("duckdns");                  // Enter your DDNS Service Name - "duckdns" / "noip"
  delay(5);
  EasyDDNS.client(duckdnsdomain, duckdnstoken); // Enter ddns Domain & Token | Example - "esp.duckdns.org","1234567"
  delay(5);
  EasyDDNS.update(DUCKDNS_REFRESHRATE);         // Check for New Ip Every 60 Seconds.
  delay(5);
  duckdnsstate = RUNNING;
}
#endif // #ifdef USEDUCKSDNS

// ======================================================================
// FIRMWARE - CHANGE AT YOUR OWN PERIL
// ======================================================================
byte TimeCheck(unsigned long x, unsigned long Delay)
{
  unsigned long y = x + Delay;
  unsigned long z = millis();                           // pick current time

  if ((x > y) && (x < z))
    return 0;                                           // overflow y
  if ((x < y) && ( x > z))
    return 1;                                           // overflow z

  return (y < z);                                       // no or (z and y) overflow
}

extern void stop_management(void);

void software_Reboot(int Reboot_delay)
{
  myoled->oledtextmsg("Reboot", -1, true, false);
  mySetupData->SaveNow();                       // save the focuser settings immediately

  // a reboot causes everything to reset, so code to stop services etc is not really needed
  delay(Reboot_delay);
  ESP.restart();
}

// move motor without updating position, used by sethomeposition
void steppermotormove(byte ddir )               // direction moving_in, moving_out ^ reverse direction
{
  // Basic assumption rule: If associated pin is -1 then cannot set enable
  if ( mySetupData->get_inoutledstate() == 1)
  {
    ( ddir == moving_in ) ? digitalWrite(mySetupData->get_brdinledpin(), 1) : digitalWrite(mySetupData->get_brdoutledpin(), 1);
  }
  driverboard->movemotor(ddir, false);
  if ( mySetupData->get_inoutledstate() == 1)
  {
    ( ddir == moving_in ) ? digitalWrite(mySetupData->get_brdinledpin(), 0) : digitalWrite(mySetupData->get_brdoutledpin(), 0);
  }
}

bool init_leds()
{
  // Basic assumption rule: If associated pin is -1 then cannot set enable
  Setup_DebugPrint("initleds: ");
  if ( mySetupData->get_inoutledstate() == 1)
  {
    pinMode(mySetupData->get_brdinledpin(), OUTPUT);
    pinMode(mySetupData->get_brdoutledpin(), OUTPUT);
    digitalWrite(mySetupData->get_brdinledpin(), 1);
    digitalWrite(mySetupData->get_brdoutledpin(), 1);
    Setup_DebugPrintln("enabled");
    return true;
  }
  else
  {
    Setup_DebugPrintln("disabled");
  }
  return false;
}

long getrssi()
{
  long strength = WiFi.RSSI();
  return strength;
}

void heapmsg()
{
  HDebugPrint("Heap = ");
  HDebugPrintf("%u\n", ESP.getFreeHeap());
}

#ifdef READWIFICONFIG
bool readwificonfig( char* xSSID, char* xPASSWORD, bool retry )
{
  const String filename = "/wificonfig.json";
  String SSID_1, SSID_2;
  String PASSWORD_1, PASSWORD_2;
  bool   mstatus = false;

  Setup_DebugPrintln("readwificonfig");
  if ( !SPIFFS.begin() )                                // SPIFFS may have failed to start
  {
    TRACE();
    Setup_DebugPrintln("err: read file");
    return mstatus;
  }
  File f = SPIFFS.open(filename, "r");                  // file open to read
  if (!f)
  {
    TRACE();
    Setup_DebugPrintln("err not found");
  }
  else
  {
    String data = f.readString();                       // read content of the text file
    Setup_DebugPrint("Config data: ");
    Setup_DebugPrintln(data);                           // ... and print on serial
    f.close();

    // DynamicJsonDocument doc( (const size_t) (JSON_OBJECT_SIZE(1) + JSON_ARRAY_SIZE(2) + 120));  // allocate json buffer
    // Using JSON assistant - https://arduinojson.org/v5/assistant/ - we need at least 372 additional bytes for esp32
    // Remember that each of the arrays have UP TO 64 chars each
    DynamicJsonDocument doc( (const size_t) (JSON_OBJECT_SIZE(4) + 372));
    DeserializationError error = deserializeJson(doc, data);    // Parse JSON object
    if (error)
    {
      TRACE();
      Setup_DebugPrintln("err: deserialize");
    }
    else
    {
      // Decode JSON/Extract values
      SSID_1     =  doc["mySSID"].as<char*>();
      PASSWORD_1 =  doc["myPASSWORD"].as<char*>();
      SSID_2     =  doc["mySSID_1"].as<char*>();
      PASSWORD_2 =  doc["myPASSWORD_1"].as<char*>();

      Setup_DebugPrint("SSID:");
      Setup_DebugPrintln(SSID_1);
      Setup_DebugPrint("PASSWORD:");
      Setup_DebugPrintln(PASSWORD_1);
      Setup_DebugPrint("SSID_1:");
      Setup_DebugPrintln(SSID_2);
      Setup_DebugPrint("PASSWORD_1:");
      Setup_DebugPrintln(PASSWORD_2);

      if ( retry == false )
      {
        // get first pair
        SSID_1.toCharArray(xSSID, SSID_1.length() + 1);
        PASSWORD_1.toCharArray(xPASSWORD, PASSWORD_1.length() + 1);
        mstatus = true;
      }
      else
      {
        // get second pair
        SSID_2.toCharArray(xSSID, SSID_2.length() + 1);
        PASSWORD_2.toCharArray(xPASSWORD, PASSWORD_2.length() + 1);
        mstatus = true;
      }
    }
  }
  return mstatus;
}
#endif

#if ((CONTROLLERMODE == ACCESSPOINT) || (CONTROLLERMODE == STATIONMODE))
void start_tcpipserver()
{
  Setup_DebugPrintln("start tcpipserver");
#if defined(ESP8266)
  myserver.begin();                       // esp8266 cannot define a port when starting
#else
  myserver.begin(mySetupData->get_tcpipport());
#endif
  tcpipserverstate = RUNNING;
}

void stop_tcpipserver()
{
  Setup_DebugPrintln("stop_tcipserver");
  myserver.stop();
  tcpipserverstate = STOPPED;
}
#endif // #if ((CONTROLLERMODE == ACCESSPOINT) || (CONTROLLERMODE == STATIONMODE))

//_______________________________________________ setup()

void setup()
{
  Serial.begin(115200);

#if (CONTROLLERMODE == LOCALSERIAL)
#if (PROTOCOL == MOONLITE_PROTOCOL)
  Serial.begin(MOONLITESERIALPORTSPEED);        // assume moonlite protocol
#else
  Serial.begin(SERIALPORTSPEED);                // assume myFP2ESP protocol
#endif
  serialline = "";
  clearSerialPort();
#endif // #if (CONTROLLERMODE == LOCALSERIAL)

#if defined(DEBUG)
#if !(CONTROLLERMODE == LOCALSERIAL)
  Serial.begin(SERIALPORTSPEED);
#endif
  Setup_DebugPrintln("Serialbegin");
  Setup_DebugPrintln("Debug on");
#endif // #if defined(DEBUG)

  delay(100);                                   // go on after statement does appear

#if defined(TIMESETUP)
  Setup_DebugPrint("setup(): ");
  Setup_DebugPrintln(millis());
#endif

  // Setup Bluetooth
#if (CONTROLLERMODE == BLUETOOTHMODE)           // open Bluetooth port, set bluetooth device name
  Setup_DebugPrintln("Start Bluetooth");
  SerialBT.begin(BLUETOOTHNAME);                // Bluetooth device name
  btline = "";
  clearbtPort();
#endif // #if (CONTROLLERMODE == BLUETOOTHMODE)

  reboot = true;                                // booting up

  varENTER_CRITICAL(&halt_alertMux);
  halt_alert = false;
  varEXIT_CRITICAL(&halt_alertMux);

  // Setup controller values
  heapmsg();
  Setup_DebugPrintln("setup(): mySetupData()");
  mySetupData = new SetupData();                // instantiate object SetUpData with SPIFFS file
  heapmsg();

  // Setup LEDS, use as controller power up indicator
  // Basic assumption rule: If associated pin is -1 then cannot set enable
  if ( mySetupData->get_inoutledstate() == 1)
  {
    Setup_DebugPrintln("IN OUT LEDS");
    bool result = init_leds();
    if ( result == true )
    {
      Setup_DebugPrintln("enabled");
    }
    else
    {
      Setup_DebugPrintln("disabled");
    }
  }
  else
  {
    Setup_DebugPrintln("disabled");
  }

  // Setup Pushbuttons, active high when pressed
  // Basic assumption rule: If associated pin is -1 then cannot set enable
  if ( mySetupData->get_pbenable() == 1)
  {
    bool result = init_pushbuttons();
    Setup_DebugPrint("Push Buttons: ");
    if ( result == true )
    {
      Setup_DebugPrintln("enabled");
    }
    else
    {
      Setup_DebugPrintln("disabled");
    }
  }
  else
  {
    Setup_DebugPrintln("disabled");
  }

  heapmsg();

  // Setup display
  displayfound = false;
#if defined(OLED_MODE)
  if (CheckOledConnected())
  {
    Setup_DebugPrintln("init OLED_MODE");
    myoled = new OLED_MODE;                       // Start configured OLED display object
    displaystate = true;
  }
  else
  {
    Setup_DebugPrintln("init OLED_NON");
    myoled = new OLED_NON;
    displaystate = false;
  }
#else
  Setup_DebugPrintln("init OLED_NON");
  myoled = new OLED_NON;
  displaystate = false;
#endif // #ifdef OLED_MODE
  Setup_DebugPrint("Display state:");
  Setup_DebugPrintln(displaystate);

  heapmsg();

  // if you want to printout the data_per.jsn settings at load time, enable SETUP_DEBUG in generalDefinitions.h

  // Setup temperature probe
  tprobe1 = 0;
  lasttemp = 20.0;
  // Basic assumption rule: If associated pin is -1 then cannot set enable
  Setup_DebugPrint("Temp probe:");
  if ( mySetupData->get_temperatureprobestate() == 1)   // if temperature probe enabled then try to start new probe
  {
    Setup_DebugPrint("mySetupData->get_temperatureprobestate() == 1");
    Setup_DebugPrintln("enabled, make new instance of probe");
    myTempProbe = new TempProbe;                        // create temp probe - should set tprobe1=true if probe found
  }
  else
  {
    tprobe1 = 0;
    Setup_DebugPrintln("disabled");
  }

  // set packet counts to 0
  packetsreceived = 0;
  packetssent = 0;
  rssi = -100;

  // read network credentials
#if  defined(READWIFICONFIG)
  Setup_DebugPrintln("Call readwificonfig");
  readwificonfig(mySSID, myPASSWORD, false);                // read mySSID,myPASSWORD from FS if exist, otherwise use defaults
#endif // #if defined(READWIFICONFIG)

  heapmsg();

  // Setup Accesspoint
#if (CONTROLLERMODE == ACCESSPOINT)
  {
    myoled->oledtextmsg("Start AP", -1, true, true);
    Setup_DebugPrintln("Start AP");
    WiFi.config(ip, dns, gateway, subnet);
    WiFi.mode(WIFI_AP);
    WiFi.softAP(mySSID, myPASSWORD);
  }
#endif // #if (CONTROLLERMODE == ACCESSPOINT)

  heapmsg();

  // Setup Stationmode, as a station connecting to an existing wifi network
#if (CONTROLLERMODE == STATIONMODE)
  Setup_DebugPrintln("Start Stationmode");
  myoled->oledtextmsg("Start Stationmode", -1, false, true);

  // Log on to LAN
  WiFi.mode(WIFI_STA);
  if (staticip == STATICIPON)                   // if staticip then set this up before starting
  {
    Setup_DebugPrintln("Set Static IP");
    myoled->oledtextmsg("Set Static IP", -1, false, true);
    WiFi.config(ip, dns, gateway, subnet);
    delay(5);
  }

  // attempt to connect using mySSID and myPASSWORD
  WiFi.begin(mySSID, myPASSWORD); // attempt to start the WiFi
  //DebugPrint("Status: ");
  //DebugPrintln(String(connstatus));
  delay(1000);                                      // wait 1s
  for (int attempts = 0; WiFi.status() != WL_CONNECTED; attempts++)
  {
    DebugPrint("Connect: ");
    DebugPrintln(mySSID);
    DebugPrint("Try=");
    DebugPrint(attempts);
    delay(1000);                                    // wait 1s

    myoled->oledtextmsg("Try", attempts, false, true);
    if (attempts > 9)                               // if this attempt is 10 or more tries
    {
      DebugPrintln("Reboot");
      myoled->oledtextmsg("Reboot" + String(mySSID), -1, true, true);
      delay(2000);
      break;                                        // jump out of this for loop
    }
  }

  // check if connected after using first set of credentials - if not connected try second pair of credentials
  if ( WiFi.status() != WL_CONNECTED )
  {
#ifdef READWIFICONFIG
    // try alternative credentials, mySSID_1, myPASSWORD_1 in the wificonfig.json file
    Setup_DebugPrintln("Call readwificonfig");
    readwificonfig(mySSID, myPASSWORD, true);
#else
    // there was no wificonfig.json file specified
    // so we will try again with 2nd pair of credentials
    // and reboot after 10 attempts to log on
    memset( mySSID, 0, 64);
    memset( myPASSWORD, 0, 64);
    memcpy( mySSID, mySSID_1, (sizeof(mySSID_1) / sizeof(mySSID_1[0]) ));
    memcpy( myPASSWORD, myPASSWORD_1, (sizeof(myPASSWORD_1) / sizeof(myPASSWORD_1[0])) );
#endif // #ifdef READWIFICONFIG
    WiFi.begin(mySSID, myPASSWORD);  // attempt to start the WiFi
    //DebugPrint("Status: ");
    //DebugPrintln(String(connstatus));
    delay(1000);                                  // wait 1s
    for (int attempts = 0; WiFi.status() != WL_CONNECTED; attempts++)
    {
      DebugPrint("Connect: ");
      DebugPrintln(mySSID);
      DebugPrint("Try=");
      DebugPrint(attempts);
      delay(1000);                                // wait 1s

      myoled->oledtextmsg("Try", attempts, false, true);
      if (attempts > 9)                           // if this attempt is 10 or more tries
      {
        DebugPrintln("Reboot");
        myoled->oledtextmsg("Reboot" + String(mySSID), -1, true, true);
        delay(2000);
        software_Reboot(2000);                    // GPIO0 must be HIGH and GPIO15 LOW when calling ESP.restart();
      }
    }
  }
#endif // #if (CONTROLLERMODE == STATIONMODE)

#if !defined(ESP8266)
  DebugPrint("WifiHostname: ");
  DebugPrintln(WiFi.getHostname());             // esp8266 has no getHostname()
#endif

  myoled->oledtextmsg("Connected", -1, true, true);
  delay(10);                                    // keep delays small else issue with ASCOM

  tcpipserverstate = STOPPED;
  mdnsserverstate = STOPPED;
  webserverstate = STOPPED;
  ascomserverstate = STOPPED;
  ascomdiscoverystate = STOPPED;
  managementserverstate = STOPPED;
  otaupdatestate = STOPPED;
  duckdnsstate = STOPPED;

  heapmsg();

  // Setup TCP/IP server to handle client requests
#if (CONTROLLERMODE == ACCESSPOINT) || (CONTROLLERMODE == STATIONMODE)
  rssi = getrssi();                             // get network strength
  // Starting TCP Server
  myoled->oledtextmsg("Start tcp/ip server", -1, false, true);
  Setup_DebugPrintln("Start tcp/ip server");
  start_tcpipserver();
  delay(10);                                    // keep delays small else issue with ASCOM
  Setup_DebugPrintln("TCP/IP started");
  myoled->oledtextmsg("TCP/IP started", -1, false, true);

  heapmsg();

  // connection established
  Setup_DebugPrint("SSID:");
  Setup_DebugPrintln(mySSID);
  Setup_DebugPrintln("Ready");
  Setup_DebugPrintln("Get IP");
  ESP32IPAddress = WiFi.localIP();
  snprintf(ipStr, sizeof(ipStr), "%i.%i.%i.%i",  ESP32IPAddress[0], ESP32IPAddress[1], ESP32IPAddress[2], ESP32IPAddress[3]);
  Setup_DebugPrint("IP:");
  Setup_DebugPrintln(ipStr);
  Setup_DebugPrint("Port:");
  Setup_DebugPrintln(SERVERPORT);
#endif // #if (CONTROLLERMODE == ACCESSPOINT) || (CONTROLLERMODE == STATIONMODE)

  // Setup Driverboard
  Setup_DebugPrint("Start drvbrd:");
  Setup_DebugPrintln(DRVBRD);
  myoled->oledtextmsg("Start drvbrd:", DRVBRD, true, true);
  heapmsg();
  // ensure targetposition will be same as focuser position
  // otherwise after loading driverboard focuser will start moving immediately
  Setup_DebugPrintln("driver board: start");
  ftargetPosition = mySetupData->get_fposition();
  driverboard = new DriverBoard( mySetupData->get_fposition() );
  Setup_DebugPrintln("driver board: end");
  delay(5);
  heapmsg();

  // Range check some focuser variables
  mySetupData->set_brdstepmode((mySetupData->get_brdstepmode() < 1 ) ? 1 : mySetupData->get_brdstepmode());
  mySetupData->set_coilpower((mySetupData->get_coilpower() >= 1) ?  1 : 0);
  mySetupData->set_reversedirection((mySetupData->get_reversedirection() >= 1) ?  1 : 0);
  if ( mySetupData->get_oledpagetime() < OLEDPAGETIMEMIN)
  {
    mySetupData->set_oledpagetime(OLEDPAGETIMEMIN);
  }
  if ( mySetupData->get_oledpagetime() > OLEDPAGETIMEMAX)
  {
    mySetupData->set_oledpagetime(OLEDPAGETIMEMAX);
  }
  mySetupData->set_maxstep((mySetupData->get_maxstep() < FOCUSERLOWERLIMIT) ? FOCUSERLOWERLIMIT : mySetupData->get_maxstep());
  mySetupData->set_stepsize((float)(mySetupData->get_stepsize() < 0.0 ) ? 0 : mySetupData->get_stepsize());
  mySetupData->set_stepsize((float)(mySetupData->get_stepsize() > MAXIMUMSTEPSIZE ) ? MAXIMUMSTEPSIZE : mySetupData->get_stepsize());

  // ensure driverboard position is same as setupData
  // set focuser position in DriverBoard
  driverboard->setposition(mySetupData->get_fposition());

  // Set coilpower
  Setup_DebugPrintln("Check CP");
  if (mySetupData->get_coilpower() == 0)
  {
    driverboard->releasemotor();
    Setup_DebugPrintln("CP off");
  }

  delay(5);

  // Setup infra red remote
#ifdef INFRAREDREMOTE
  // Basic assumption rule: If associated pin is -1 then cannot set enable
  if ( mySetupData->get_brdirpin() != 1)
  {
    Setup_DebugPrintln("ir-remote enabled");
    init_irremote();
  }
  else
  {
    Setup_DebugPrintln("ir-remote pin disabled");
  }
#endif // #ifdef INFRAREDREMOTE

  // Setup joystick
#ifdef JOYSTICK1
  init_joystick1();
#endif

#ifdef JOYSTICK2
  init_joystick2();
#endif

  isMoving = 0;

  // Basic assumption rule: If associated pin is -1 then cannot set enable
  if ( mySetupData->get_temperatureprobestate() == 1)     // if temp probe "enabled" state
  {
    Setup_DebugPrintln("mySetupData->get_temperatureprobestate() = 1");
    if ( tprobe1 != 0 )                                   // if a probe was found
    {
      Setup_DebugPrintln("tprobe1 != 0");
      Setup_DebugPrintln("myTempProbe->read_temp(1)");
      myTempProbe->read_temp(1);                          // read the temperature
    }
    else
    {
      Setup_DebugPrintln("tprobe1 is 0");
      mySetupData->set_temperatureprobestate(0);          // disable temperature probe
    }
  }
  else
  {
    Setup_DebugPrintln("mySetupData->get_temperatureprobestate() != 1");
  }

#if (CONTROLLERMODE == STATIONMODE)
  // Start the OTA service
#ifdef OTAUPDATES
  Setup_DebugPrintln("Start otaservice");
  start_otaservice();
#endif // if defined(OTAUPDATES)

#ifdef MDNSSERVER
  Setup_DebugPrintln("start mdns server");
  start_mdns_service();
#endif

  // setup duckdns
#ifdef USEDUCKDNS
  Setup_DebugPrintln("start duckdns");
  init_duckdns();
#endif
#endif // #if (CONTROLLERMODE == STATIONMODE) 

  heapmsg();

  // Start management server
#if ( (CONTROLLERMODE == ACCESSPOINT) || (CONTROLLERMODE == STATIONMODE) )
#ifdef MANAGEMENT
  Setup_DebugPrintln("setup(): management server");
  start_management();
#endif // #ifdef MANAGEMENT
#endif // #if ((CONTROLLERMODE == ACCESSPOINT) || (CONTROLLERMODE == STATIONMODE) )

  heapmsg();

#if ( (CONTROLLERMODE == ACCESSPOINT) || (CONTROLLERMODE == STATIONMODE) )
  // Start Webserver
  if ( mySetupData->get_webserverstate() == 1)
  {
    Setup_DebugPrintln("start web server");
    start_webserver();
  }
#endif // #if ((CONTROLLERMODE == ACCESSPOINT) || (CONTROLLERMODE == STATIONMODE) )

  heapmsg();

  // Setup ASCOM server
#if ((CONTROLLERMODE == ACCESSPOINT) || (CONTROLLERMODE == STATIONMODE) )
  if ( mySetupData->get_ascomserverstate() == 1)
  {
    Setup_DebugPrintln("start ascom server");
    start_ascomremoteserver();
  }
#endif // #if ((CONTROLLERMODE == ACCESSPOINT) || (CONTROLLERMODE == STATIONMODE) )

  heapmsg();

  Setup_DebugPrint("Position:");
  Setup_DebugPrintln(driverboard->getposition());
  Setup_DebugPrint("Target Position");
  Setup_DebugPrintln(ftargetPosition);
  Setup_DebugPrintln("Setup done");
  myoled->oledtextmsg("Setup done", -1, false, true);

  // Basic assumption rule: If associated pin is -1 then cannot set enable
  if ( mySetupData->get_inoutledstate() == 1)
  {
    digitalWrite(mySetupData->get_brdinledpin(), 0);
    digitalWrite(mySetupData->get_brdoutledpin(), 0);
  }

  reboot = false;                                           // we have finished the reboot now

  cachepresets();
  
#if defined(TIMESETUP)
  Setup_DebugPrint("setup(): ");
  Setup_DebugPrintln(millis());
#endif
}

//_____________________ loop()___________________________________________

void loop()
{
  static StateMachineStates MainStateMachine = State_Idle;
  static uint32_t backlash_count = 0;
  static bool     DirOfTravel = (bool) mySetupData->get_focuserdirection();
  static uint32_t TimeStampDelayAfterMove = 0;
  static uint32_t TimeStampPark = millis();
  static bool     Parked = true;                  // focuser cannot be moving as it was just started
  static bool     tms = false;                    // timersemaphore
  static uint8_t  updatecount = 0;
  static uint32_t steps = 0;

  static connection_status ConnectionStatus = disconnected;
  static oled_state oled = oled_on;

  int stepstaken = 0;
  bool hpswstate = false;

#if defined(TIMELOOP)
  Setup_DebugPrint("loop(): ");
  Setup_DebugPrintln(millis());
#endif // #if defined(TIMELOOP)

#if ( (CONTROLLERMODE == ACCESSPOINT) || (CONTROLLERMODE == STATIONMODE) )
  if (ConnectionStatus == disconnected)
  {
    myclient = myserver.available();
    if (myclient)
    {
      if (myclient.connected())
      {
        DebugPrintln("tcp client connected");
        ConnectionStatus = connected;
        // a client has connected, start oled display again
        // oled = oled_on;
      }
    }
  }
  else
  {
    // is data available from the client request
    if (myclient.connected())
    {
      if (myclient.available())
      {
        ESP_Communication(); // Wifi communication
        // client has sent a request, turn display on
        // oled = olen_on;
      }
    }
    else
    {
      DebugPrintln("tcp client disconnectd");
      myclient.stop();
      ConnectionStatus = disconnected;
      // client has disconnected, turn display off
      oled = oled_off;
    }
  }
#endif // #if ( (CONTROLLERMODE == ACCESSPOINT) || (CONTROLLERMODE == STATIONMODE) )

#if (CONTROLLERMODE == BLUETOOTHMODE)
  if ( SerialBT.available() )
  {
    processbt();
  }
  // if there is a command from Bluetooth
  if ( queue.count() >= 1 )                 // check for serial command
  {
    ESP_Communication();
  }
#endif // ifdef Bluetoothmode

#if (CONTROLLERMODE == LOCALSERIAL)
  // if there is a command from Serial port
  if ( Serial.available() )
  {
    processserial();
  }
  if ( queue.count() >= 1 )                 // check for serial command
  {
    ESP_Communication();
  }
#endif // #if (CONTROLLERMODE == LOCALSERIAL)

#if ( (CONTROLLERMODE == ACCESSPOINT) || (CONTROLLERMODE == STATIONMODE) )
#ifdef OTAUPDATES
  if ( otaupdatestate == RUNNING )
  {
    ArduinoOTA.handle();                      // listen for OTA events
  }
#endif // ifdef OTAUPDATES
#endif // #if ( (CONTROLLERMODE == ACCESSPOINT) || (CONTROLLERMODE == STATIONMODE) )

#if ( (CONTROLLERMODE == ACCESSPOINT) || (CONTROLLERMODE == STATIONMODE) )
  if ( ascomserverstate == RUNNING)
  {
    ascomserver->handleClient();
    checkASCOMALPACADiscovery();
  }
#endif // #if ( (CONTROLLERMODE == ACCESSPOINT) || (CONTROLLERMODE == STATIONMODE) )

#if ( (CONTROLLERMODE == ACCESSPOINT) || (CONTROLLERMODE == STATIONMODE) )
  if ( webserverstate == RUNNING )
  {
    webserver->handleClient();
  }
#endif // #if ( (CONTROLLERMODE == ACCESSPOINT) || (CONTROLLERMODE == STATIONMODE) )

#if ( (CONTROLLERMODE == ACCESSPOINT) || (CONTROLLERMODE == STATIONMODE) )
#ifdef MANAGEMENT
  if ( managementserverstate == RUNNING )
  {
    mserver.handleClient();
  }
#endif
#endif // #if ( (CONTROLLERMODE == ACCESSPOINT) || (CONTROLLERMODE == STATIONMODE) )
  //_____________________________MainMachine _____________________________

  switch (MainStateMachine)
  {
    case State_Idle:
      if (driverboard->getposition() != ftargetPosition)
      {
        // we are going to move focuser, enable display
        // oled = oled_on;
        isMoving = 1;
        driverboard->enablemotor();
        MainStateMachine = State_InitMove;
        DebugPrint("go init_move");
        DebugPrint("Position:");
        DebugPrintln(driverboard->getposition());
        DebugPrint("Target:");
        DebugPrintln(ftargetPosition);
      }
      else
      {
        // focuser stationary. isMoving is 0
        if (mySetupData->SaveConfiguration(driverboard->getposition(), DirOfTravel)) // save config if needed
        {
          // we have waited 30s after move has ended so turn off display
          oled = oled_off;
          DebugPrint("Save config");
        }

        update_pushbuttons();

#ifdef JOYSTICK1
        update_joystick1();
#endif
#ifdef JOYSTICK2
        update_joystick2();
#endif
#ifdef INFRAREDREMOTE
        update_irremote();
#endif
        if (mySetupData->get_displayenabled() == 1)
        {
          myoled->update_oledtextdisplay();
        }
        else
        {
          oled = oled_off;
        }
        myoled->Update_Oled(oled, ConnectionStatus);

        if ( mySetupData->get_temperatureprobestate() == 1)           // if probe is enabled
        {
          if ( tprobe1 != 0 )                                         // if probe was found
          {
            DebugPrintln("tprobe1 = 1");
            DebugPrintln("update_temp()");
            myTempProbe->update_temp();
          }
          else
          {
            DebugPrintln("tprobe1 = 0");
          }
        }

        // Parked is set false after State_DelayAfterMove is ended
        if (Parked == false)
        {
          if (TimeCheck(TimeStampPark, mySetupData->get_coilpower_timeout()))   // coil power off after delay time expired
          {
            // need to obey rule - can only release motor if coil power is disabled
            if ( mySetupData->get_coilpower() == 0 )
            {
              driverboard->releasemotor();
              DebugPrintln("CP=off");
            }
            Parked = true;
          } // if (TimeCheck(TimeStampPark, MotorReleaseDelay))
        } // if (Parked == false)
      } // if (driverboard->getposition() != ftargetPosition)
      break;

    case State_InitMove:
      isMoving = 1;
      backlash_count = 0;
      DirOfTravel = (ftargetPosition > driverboard->getposition()) ? moving_out : moving_in;
      driverboard->enablemotor();
      if (mySetupData->get_focuserdirection() != DirOfTravel)
      {
        mySetupData->set_focuserdirection(DirOfTravel);
        // move is in opposite direction, check for backlash enabled
        // get backlash settings
        if ( DirOfTravel == moving_in)
        {
          if (mySetupData->get_backlash_in_enabled())
          {
            backlash_count = mySetupData->get_backlashsteps_in();
          }
        }
        else
        {
          if (mySetupData->get_backlash_out_enabled())
          {
            backlash_count = mySetupData->get_backlashsteps_out();
          }
        } // if ( DirOfTravel == moving_in)
        /*
                if (DirOfTravel != moving_main && backlash_count)
                {
                  uint32_t sm = mySetupData->get_stepmode();
                  uint32_t bl = backlash_count * sm;
                  DebugPrint("bl: ");
                  DebugPrint(bl);
                  DebugPrint(" ");

                  if (DirOfTravel == moving_out)
                  {
                    backlash_count = bl + sm - ((ftargetPosition + bl) % sm); // Trip to tuning point should be a fullstep position
                  }
                  else
                  {
                    backlash_count = bl + sm + ((ftargetPosition - bl) % sm); // Trip to tuning point should be a fullstep position
                  }

                  DebugPrint("backlash_count: ");
                  DebugPrint(backlash_count);
                  DebugPrint(" ");
                } // if (DirOfTravel != moving_main && backlash_count)
                else
                {
                   DebugPrintln("false");
                }
        */
      } // if (mySetupData->get_focuserdirection() != DirOfTravel)

      // if target pos > current pos then steps = target pos - current pos
      // if target pos < current pos then steps = current pos - target pos
      steps = (ftargetPosition > driverboard->getposition()) ? ftargetPosition - driverboard->getposition() : driverboard->getposition() - ftargetPosition;

      // Error - cannot combine backlash steps to steps because that alters position
      // Backlash move SHOULD NOT alter focuser position as focuser is not actually moving
      // backlash is taking up the slack in the stepper motor/focuser mechanism, so position is not actually changing
      if ( backlash_count != 0 )
      {
        DebugPrintln("go backlash");
        MainStateMachine = State_Backlash;
      }
      else
      {
        // if target pos > current pos then steps = target pos - current pos
        // if target pos < current pos then steps = current pos - target pos
        driverboard->initmove(DirOfTravel, steps);
        DebugPrint("Steps: ");
        DebugPrintln(steps);
        DebugPrintln("go moving");
        MainStateMachine = State_Moving;
      }
      break;

    case State_Backlash:
      // apply backlash
      DebugPrint("Apply Backlash: Steps=");
      DebugPrintln(backlash_count);
      while ( backlash_count != 0 )
      {
        steppermotormove(DirOfTravel);                            // take 1 step and do not adjust position
        delayMicroseconds(mySetupData->get_brdmsdelay());         // ensure delay between steps
        backlash_count--;
        if (driverboard->hpsw_alert() )                           // check if home position sensor activated?
        {
          DebugPrintln("HPS_alert() during backlash move");
          varENTER_CRITICAL(&timerSemaphoreMux);
          timerSemaphore = false;                                 // move finished
          varEXIT_CRITICAL(&timerSemaphoreMux);
          backlash_count = 0;                                     // drop out of while loop
          MainStateMachine = State_Moving;                        // change state to State_Moving and handle HPSW
        }
      }
      if ( MainStateMachine == State_Backlash )                   // finished backlash move, so now move motor #steps
      {
        DebugPrintln("Backlash done");
        DebugPrint("Initiate motor move- steps: ");
        DebugPrintln(steps);
        driverboard->initmove(DirOfTravel, steps);
        DebugPrintln("go moving");
        MainStateMachine = State_Moving;
      }
      else
      {
        // MainStateMachine is State_Moving - timerSemaphore is false. is then caught by if(driverboard->hpsw_alert() ) and HPSW is processed
      }
      break;

    //_______________________________State_Moving

    case State_Moving:
      //DebugPrintln("S_M");
      varENTER_CRITICAL(&timerSemaphoreMux);
      tms = timerSemaphore;
      varEXIT_CRITICAL(&timerSemaphoreMux);
      if ( tms == true )
      {
        // move has completed, the driverboard keeps track of focuser position
        DebugPrintln("Move completed");
        driverboard->end_move();                          // disable interrupt timer that moves motor
        TimeStampDelayAfterMove = millis();
        DebugPrintln("go DelayAfterMove");
        MainStateMachine = State_DelayAfterMove;
      }
      else
      {
        // timer semaphore is false. still moving, we need to check for halt
        if ( halt_alert )                                 // halt_alert set by comms.h webserver.cpp
        {
          DebugPrintln("halt_alert");
          varENTER_CRITICAL(&halt_alertMux);
          halt_alert = false;                             // reset alert flag
          varEXIT_CRITICAL(&halt_alertMux);
          driverboard->end_move();                        // disable interrupt timer that moves motor
          ftargetPosition = driverboard->getposition();
          mySetupData->set_fposition(driverboard->getposition());
          // we no longer need to keep track of steps here or halt because driverboard updates position on every move
          DebugPrintln("go DelayAfterMove");
          TimeStampDelayAfterMove = millis();
          MainStateMachine = State_DelayAfterMove;
        } // if ( halt_alert )

        if ( driverboard->hpsw_alert() )                  // and we need to check if home position sensor activated?
        {
          driverboard->end_move();                        // disable interrupt timer that moves motor
          if (driverboard->getposition() > 0)
          {
            DebugPrintln("HP Sw=1, Pos not 0");
          }
          else
          {
            DebugPrintln("HP Sw=1, Pos=0");
          } // if (driverboard->getposition() > 0)
          ftargetPosition = 0;
          driverboard->setposition(0);
          mySetupData->set_fposition(0);
          if ( mySetupData->get_showhpswmsg() == 1)       // check if display home position messages is enabled
          {
            if (mySetupData->get_displayenabled() == 1)
            {
              myoled->oledtextmsg("HP Sw=1, Pos=0", -1, true, true);
            }
          }
          if ( mySetupData->get_brdnumber() == PRO2ESP32TMC2209 || mySetupData->get_brdnumber() == PRO2ESP32TMC2209P )
          {
#if defined(USE_STALL_GUARD)
            // are home and no need to handle set position, simple
            DebugPrintln("Stall Guard: Pos = 0");
            TimeStampDelayAfterMove = millis();
            MainStateMachine = State_DelayAfterMove;
#else
            // not stall guard must be physical switch then we should jump to set home position
            DebugPrintln("go SetHomePosition");
            MainStateMachine = State_SetHomePosition;
#endif // #if defined(USE_STALL_GUARD)
          }
          else // not a tmc2209 board
          {
            // we should jump to
            DebugPrintln("go SetHomePosition");
            MainStateMachine = State_SetHomePosition;
          } // if ( mySetupData->get_brdnumber() == PRO2ESP32TMC2209 || mySetupData->get_brdnumber() == PRO2ESP32TMC2209P )
        } // if (driverboard->hpsw_alert() )

        // if the update position on display when moving is enabled, then update the display
        if ( mySetupData->get_oledupdateonmove() == 1)
        {
          // update position counter on display if there is an enabled display
          if (mySetupData->get_displayenabled() == 1)
          {
            updatecount++;
            if ( updatecount > OLEDUPDATEONMOVE )        // only update every 15th move to avoid overhead
            {
              updatecount = 0;
              myoled->update_oledtext_position();
            }
          } // if (mySetupData->get_displayenabled() == 1)
        } // if ( get_oledupdateonmove() == 1)
      }
      break;

    case State_SetHomePosition:                           // move out till home position switch opens
      DebugPrintln("State_SetHomePosition");
      if ( mySetupData->get_hpswitchenable() == 1)
      {
        // check if display home position switch messages is enabled
        if ( mySetupData->get_showhpswmsg() == 1)
        {
          if (mySetupData->get_displayenabled() == 1)
          {
            myoled->oledtextmsg("HP Sw=0, Mov out", -1, false, true);
          }
        }
        // HOME POSITION SWITCH IS CLOSED - Step out till switch opens then set position = 0
        stepstaken = 0;                                   // Count number of steps to prevent going too far
        DebugPrintln("HP Sw=0, Mov out");
        DirOfTravel = !DirOfTravel;                       // We were going in, now we need to reverse and go out
        hpswstate = HPSWCLOSED;                           // We know we got here because switch was closed
        while ( hpswstate == HPSWCLOSED )                 // while hpsw = closed = true = 1
        {
          if ( mySetupData->get_reversedirection() == 0 )
          {
            steppermotormove(DirOfTravel);                // take 1 step
          }
          else
          {
            steppermotormove(!DirOfTravel);
          }

          delayMicroseconds(mySetupData->get_brdmsdelay()); // Ensure delay between steps

          stepstaken++;                                   // increment steps taken
          if ( stepstaken > HOMESTEPS )                   // this prevents the endless loop if the hpsw is not connected or is faulty
          {
            DebugPrintln("HP Sw=0, Mov out err");
            hpswstate = HPSWOPEN;
          }
          else
          {
            hpswstate = driverboard->hpsw_alert();        // hpsw_alert returns true if closed, false = open
          }
        }
        DebugPrint("HP Sw, Mov out steps:");
        DebugPrintln(stepstaken);
        DebugPrintln("HP Sw=0, Mov out ok");
        ftargetPosition = 0;
        driverboard->setposition(0);
        mySetupData->set_fposition(0);

        mySetupData->set_focuserdirection(DirOfTravel);   // set direction of last move

        if ( mySetupData->get_showhpswmsg() == 1)         // check if display home position switch messages is enabled
        {
          if (mySetupData->get_displayenabled() == 1)
          {
            myoled->oledtextmsg("HP Sw=0, Mov out ok", -1, true, true);
          }
        }
      } //  if( mySetupData->get_homepositionswitch() == 1)

      MainStateMachine = State_DelayAfterMove;
      TimeStampDelayAfterMove = millis();
      DebugPrintln("go DelayAfterMove");
      break;

    //_______________________________State_DelayAfterMove

    case State_DelayAfterMove:
      heapmsg();
      // apply Delayaftermove, this MUST be done here in order to get accurate timing for DelayAfterMove
      if (TimeCheck(TimeStampDelayAfterMove , mySetupData->get_DelayAfterMove()))
      {
        oled = oled_on;
        isMoving = 0;
        TimeStampPark  = millis();                      // catch current time
        Parked = false;                                 // mark to park the motor in State_Idle
        DebugPrintln("go idle");
        MainStateMachine = State_Idle;
      }
      break;

    default:
      DebugPrintln("Err: wrong State");
      DebugPrintln("go idle");
      MainStateMachine = State_Idle;
      break;
  }

#if defined(TIMELOOP)
  Setup_DebugPrint("loop(): ");
  Setup_DebugPrintln(millis());
#endif
} // end Loop()
